SELECT EMPLOYEE_ID "Id Empleado"
    , NVL(TO_CHAR(MANAGER_ID),'No tiene Jefe') "Jefacion o no jefacion"
FROM EMPLOYEES
ORDER BY 1;

SELECT EMPLOYEE_ID "Id Empleado"
    , COALESCE(TO_CHAR(MANAGER_ID),'No tiene Jefe') "Jefacion o no jefacion"
FROM EMPLOYEES
ORDER BY 1;

-- Forma rebuscada de narices
SELECT EMPLOYEE_ID "Id Empleado"
    , DECODE(MANAGER_ID
            ,NULL, 'Sin Jefe'
            ,MANAGER_ID)
FROM EMPLOYEES
ORDER BY 1;
SELECT EMPLOYEE_ID "Id Empleado",
       NVL2(MANAGER_ID, TO_CHAR(MANAGER_ID), 'No tiene Jefe') "Jefacion o no jefacion"
FROM EMPLOYEES
ORDER BY 1;

SELECT EMPLOYEE_ID "Id Empleado",
       CASE
           WHEN MANAGER_ID IS NOT NULL THEN TO_CHAR(MANAGER_ID)
           ELSE 'No tiene Jefe'
       END "Posesion de Jefe"
FROM EMPLOYEES
ORDER BY 1;

SELECT FIRST_NAME
    , LPAD(FIRST_NAME, 6,'-')
    , RPAD(FIRST_NAME, 6,'-')
FROM EMPLOYEES
ORDER BY 2;

---------------------------JOINS--------------------------
En la clausula WHERE se mezclan las condiciones de union con las de filtrado. Ten cuidado con la mezclacion y no liarte, mejor separar claramente dentro de la clausula

Metodo ANSI - Metes la condicion de combinacion en la clausula FROM junto con el tipo de JOIN que lo utilices

---------------Producto Cartesiano----------------
La mayoria de veces que lo ves es que esta mal, es simplemente una union sin condicion de union. Es a lo bruto.

-- Forma de bruto sin conciencia
SELECT COUNT(*)
FROM EMPLOYEES, DEPARTMENTS;

--Forma de persona que no ha tenido mas remedio
SELECT COUNT(*)
FROM DEPARTMENTS CROSS JOIN EMPLOYEES
WHERE DEPARTMENTS.DEPARTMENT_ID
    =EMPLOYEES.DEPARTMENT_ID

--Join en Clausula From
SELECT DEPARTMENT
FROM DEPARTMENTS CROSS JOIN EMPLOYEES
WHERE DEPARTMENTS.DEPARTMENT_ID
    =EMPLOYEES.DEPARTMENT_ID

SELECT EMPLOYEE_ID 
    ,REGION_NAME
FROM EMPLOYEES, DEPARTMENTS	, LOCATIONS, COUNTRIES, REGIONS
WHERE REGIONS.REGION_ID=COUNTRIES.REGION_ID
    AND COUNTRIES.COUNTRY_ID=LOCATIONS.COUNTRY_ID
    AND LOCATIONS.LOCATION_ID=DEPARTMENTS.LOCATION_ID
    AND DEPARTMENTS.DEPARTMENT_ID=EMPLOYEES.DEPARTMENT_ID
ORDER BY 1;

--Natural join
Coge automaticamente las condiciones de union de las tablas, no hace falta copiarlas. El Oracle SQL Developer no soporta los NATURAL JOIN porque no es profesional, tienes que hacer el tipo de join correspondiente. Busca todas los atributos iguales de las dos tablas y los usa como criterios de union. Es la solucion mas rapida

SELECT REGION_NAME, COUNTRY_NAME
FROM REGIONS NATURAL JOIN COUNTRIES
ORDER BY 1;

SELECT REGION_NAME, COUNTRY_NAME, DEPARTMENT_NAME, EMPLOYEE_ID
FROM REGIONS NATURAL JOIN COUNTRIES
             NATURAL JOIN LOCATIONS
             NATURAL JOIN DEPARTMENTS
             NATURAL JOIN EMPLOYEES -- No es adecuada porque esta utilizando como condicion de union que el identificador del manager y el del departamento sea igual. Informando solo de los managers que trabajan en el mismo departamento que gestionan
ORDER BY 1;

SELECT REGION_NAME, COUNTRY_NAME, DEPARTMENT_NAME, EMPLOYEE_ID
FROM REGIONS NATURAL JOIN COUNTRIES
             NATURAL JOIN LOCATIONS
             NATURAL JOIN DEPARTMENTS
             INNER JOIN EMPLOYEES ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID
ORDER BY 1;

SELECT REGION_NAME, COUNTRY_NAME, DEPARTMENT_NAME, EMPLOYEE_ID
FROM REGIONS
    INNER JOIN COUNTRIES ON REGIONS.REGION_ID = COUNTRIES.REGION_ID
    INNER JOIN LOCATIONS ON COUNTRIES.COUNTRY_ID = LOCATIONS.COUNTRY_ID
    INNER JOIN DEPARTMENTS ON LOCATIONS.LOCATION_ID = DEPARTMENTS.LOCATION_ID
    INNER JOIN EMPLOYEES ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID
ORDER BY 1;

EQUI JOIN
-- Utiliza como criterio de join una igualdad, todo criterio que no sea de igualdad es no equi join

-- Que trabajos e id de trabajo podrian ser adecuadas con la banda salarial donde se encuentre el empleado




SELECT EMPLOYEES.FIRST_NAME
    , EMPLOYEES.LAST_NAME
    , JOBS.JOB_ID
    , JOB_TITLE
FROM JOBS
    INNER JOIN EMPLOYEES ON EMPLOYEES.SALARY BETWEEN JOBS.MIN_SALARY AND JOBS.MAX_SALARY
ORDER BY EMPLOYEES.FIRST_NAME,JOBS.JOB_ID;

-- OUTER JOIN --
Permite visualizar aquellas filas que no cumplen la condicion de union
--Ejemplo con INNER
SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    INNER JOIN EMPLOYEES USING (DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME
ORDER BY 1;
-- Si queremos que tambien nos aparezcan aquellos departamentos que no tengan empleados asignados a departamentos
SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    LEFT OUTER JOIN EMPLOYEES USING (DEPARTMENT_ID)
    --LEFT OUTER JOIN EMPLOYEES ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME
ORDER BY 1;
-- Notacion Tradicional LEFT OUTER JOIN
SELECT DEPARTMENT_NAME
    ,FIRST_NAME
    ,LAST_NAME
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID=E.DEPARTMENT_ID(+)


-- Si queremos que tambien nos aparezcan aquellos empleados que no tengan departamentos asignados
SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    RIGHT OUTER JOIN EMPLOYEES USING (DEPARTMENT_ID)
    --RIGHT OUTER JOIN EMPLOYEES ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME
ORDER BY 1;
-- Notacion Tradicional RIGHT OUTER JOIN, el (+) indica los campos que estan vacios, en este caso, los departamento
SELECT DEPARTMENT_NAME
    ,FIRST_NAME
    ,LAST_NAME
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID(+)=E.DEPARTMENT_ID

--Si queremos ver tantos los departamentos que no tengan empleados asignados como a aquellos empleados que no tengan departamentos asignados
SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    FULL OUTER JOIN EMPLOYEES USING (DEPARTMENT_ID)
    --FULL OUTER JOIN EMPLOYEES ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME
ORDER BY 1;

SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    LEFT OUTER JOIN EMPLOYEES USING (DEPARTMENT_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME
UNION
SELECT DEPARTMENT_NAME "DPTO."
    , COUNT(EMPLOYEE_ID) "NºEmpleados"
FROM DEPARTMENTS
    RIGHT OUTER JOIN EMPLOYEES USING (DEPARTMENT_ID)
ORDER BY 1;
-- Notacion Tradicional FULL OUTER JOIN
SELECT DEPARTMENT_NAME
    ,FIRST_NAME
    ,LAST_NAME
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID=E.DEPARTMENT_ID(+)
UNION
SELECT DEPARTMENT_NAME
    ,FIRST_NAME
    ,LAST_NAME
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID(+)=E.DEPARTMENT_ID

--Dame el id de departamento de aqellos departamentos qeu tengan empleados. 
--Utilizamos un SEMI JOIN. Esto solo sirve para comprobar si existen datos que cumplan la condicion, es decir, comprobamos que exista relacion
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE EXISTS (SELECT *
                FROM EMPLOYEES
                WHERE EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID);

--ANTIJOIN: Comprobamos que datos no estan relacionados
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE NOT EXISTS (SELECT *
                FROM EMPLOYEES
                WHERE EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID);

1
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME "Nombre Completo Empleado"
    , D.DEPARTMENT_NAME "Nombre del Departamento"
FROM EMPLOYEES E
    INNER JOIN DEPARTMENTS D USING (DEPARTMENT_ID)
ORDER BY 2,1;

2 --Trabajos que se realizan en cada pais (JOB_TITLE, COUNTRY_NAME)
SELECT DISTINCT JOB_TITLE "Trabajo"
    , COUNTRY_NAME "Pais"
FROM COUNTRIES
    INNER JOIN LOCATIONS USING (COUNTRY_ID)
    INNER JOIN DEPARTMENTS USING (LOCATION_ID)
    INNER JOIN EMPLOYEES USING (DEPARTMENT_ID)
    INNER JOIN JOBS USING (JOB_ID)
ORDER BY 2,1;

3
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME "Nombre Completo Empleado"
    , D.DEPARTMENT_NAME "Nombre del Departamento Empleado"
    , M.FIRST_NAME || ' ' || M.LAST_NAME "Nombre Completo Jefe"
    , DR.DEPARTMENT_NAME "Nombre del Departamento Jefe"
FROM EMPLOYEES E
    INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    INNER JOIN EMPLOYEES M ON E.MANAGER_ID=M.EMPLOYEE_ID
    INNER JOIN DEPARTMENTS DR ON M.DEPARTMENT_ID=DR.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID != M.DEPARTMENT_ID
ORDER BY 1,2;

4
SELECT EMPLOYEES.FIRST_NAME || ' ' || EMPLOYEES.LAST_NAME AS "Nombre Completo",
       TO_CHAR((JOBS.MAX_SALARY / EMPLOYEES.SALARY) - 1, '.9999') AS "Comision Maxima"
FROM JOBS
    INNER JOIN EMPLOYEES USING (JOB_ID)
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
WHERE INITCAP(DEPARTMENTS.DEPARTMENT_NAME) = 'Sales'
ORDER BY 1;

5
SELECT COUNT(EMPLOYEES.EMPLOYEE_ID) 
    , REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
    , LOCATIONS.CITY
FROM EMPLOYEES
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN LOCATIONS USING (LOCATION_ID)
    INNER JOIN COUNTRIES USING (COUNTRY_ID)
    INNER JOIN REGIONS USING (REGION_ID)
GROUP BY REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
    , LOCATIONS.CITY
ORDER BY 1 DESC, 2,3,4;
----------------------------Solucion------------------------
SELECT DISTINCT COUNT(EMPLOYEES.EMPLOYEE_ID) 
    , REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
    , LOCATIONS.CITY
FROM EMPLOYEES
    LEFT OUTER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN LOCATIONS USING (LOCATION_ID)
    INNER JOIN COUNTRIES USING (COUNTRY_ID)
    INNER JOIN REGIONS USING (REGION_ID)
GROUP BY REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
    , LOCATIONS.CITY
UNION
SELECT DISTINCT COUNT(EMPLOYEES.EMPLOYEE_ID) 
    , REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
    , NULL
FROM EMPLOYEES
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN LOCATIONS USING (LOCATION_ID)
    INNER JOIN COUNTRIES USING (COUNTRY_ID)
    INNER JOIN REGIONS USING (REGION_ID)
GROUP BY REGIONS.REGION_NAME
    , COUNTRIES.COUNTRY_NAME
UNION
SELECT DISTINCT COUNT(EMPLOYEES.EMPLOYEE_ID) 
    , REGIONS.REGION_NAME
    , NULL
    , NULL
FROM EMPLOYEES
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN LOCATIONS USING (LOCATION_ID)
    INNER JOIN COUNTRIES USING (COUNTRY_ID)
    INNER JOIN REGIONS USING (REGION_ID)
GROUP BY REGIONS.REGION_NAME
UNION
SELECT DISTINCT COUNT(EMPLOYEES.EMPLOYEE_ID) 
    , NULL
    , NULL
    , NULL
FROM EMPLOYEES
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN LOCATIONS USING (LOCATION_ID)
    INNER JOIN COUNTRIES USING (COUNTRY_ID)
    INNER JOIN REGIONS USING (REGION_ID)
ORDER BY 1, 2,3,4;

6
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS "Nombre Completo"
    , DEPARTMENTS.DEPARTMENT_NAME "Dpto."
FROM EMPLOYEES E
    INNER JOIN DEPARTMENTS USING (DEPARTMENT_ID)
    INNER JOIN EMPLOYEES M ON E.MANAGER_ID=M.EMPLOYEE_ID
WHERE E.SALARY > M.SALARY
ORDER BY 1,2;

7
SELECT DEPARTMENT_NAME "Nombre Departamento"
    , COUNT(E.EMPLOYEE_ID) "Numero de empleados"
    , CASE
        WHEN MAX(M.EMPLOYEE_ID) IS NOT NULL THEN MAX(M.FIRST_NAME || ' ' || M.LAST_NAME)
        ELSE 'No tiene Jefe' 
        END "Nombre Completo Jefe"
FROM EMPLOYEES E
    RIGHT OUTER JOIN DEPARTMENTS D USING (DEPARTMENT_ID)
    LEFT OUTER JOIN EMPLOYEES M ON E.MANAGER_ID=M.EMPLOYEE_ID
GROUP BY DEPARTMENT_NAME
ORDER BY 1;

8
SELECT 
    DEPARTMENT_NAME "Nombre Departamento",
    CASE
        WHEN COUNT(E.EMPLOYEE_ID) != 0 THEN TO_CHAR(COUNT(E.EMPLOYEE_ID))
        ELSE 'Sin empleados' 
    END "Numero de empleados",
    CASE
        WHEN MAX(M.EMPLOYEE_ID) IS NOT NULL THEN MAX(M.FIRST_NAME || ' ' || M.LAST_NAME)
        ELSE 'No tiene Jefe' 
    END "Nombre Completo Jefe"
FROM EMPLOYEES E
    RIGHT OUTER JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
    LEFT OUTER JOIN EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
GROUP BY DEPARTMENT_NAME
ORDER BY 1;

9
